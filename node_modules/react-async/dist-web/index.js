import React, { useEffect, useRef, useReducer, useDebugValue, useMemo, useCallback } from 'react';

/**
 * Universal global scope object. In the browser this is `self`, in Node.js and React Native it's `global`.
 */
var globalScope = (() => {
  if (typeof self === "object" && self.self === self) return self;
  if (typeof global === "object" && global.global === global) return global;
  if (typeof global === "object" && global.GLOBAL === global) return global;
  return {}; // fallback that relies on imported modules to be singletons
})();
/**
 * Globally available object used to connect the DevTools to all React Async instances.
 */


globalScope.__REACT_ASYNC__ = globalScope.__REACT_ASYNC__ || {};

var PropTypes;

try {
  PropTypes = require("prop-types");
} catch (e) {}

var childrenFn = PropTypes && PropTypes.oneOfType([PropTypes.node, PropTypes.func]);
var stateObject = PropTypes && PropTypes.shape({
  initialValue: PropTypes.any,
  data: PropTypes.any,
  error: PropTypes.instanceOf(Error),
  value: PropTypes.any,
  startedAt: PropTypes.instanceOf(Date),
  finishedAt: PropTypes.instanceOf(Date),
  status: PropTypes.oneOf(["initial", "pending", "fulfilled", "rejected"]),
  isInitial: PropTypes.bool,
  isPending: PropTypes.bool,
  isLoading: PropTypes.bool,
  isFulfilled: PropTypes.bool,
  isResolved: PropTypes.bool,
  isRejected: PropTypes.bool,
  isSettled: PropTypes.bool,
  counter: PropTypes.number,
  cancel: PropTypes.func,
  run: PropTypes.func,
  reload: PropTypes.func,
  setData: PropTypes.func,
  setError: PropTypes.func
});
var propTypes = PropTypes && {
  Async: {
    children: childrenFn,
    promise: PropTypes.instanceOf(Promise),
    promiseFn: PropTypes.func,
    deferFn: PropTypes.func,
    watch: PropTypes.any,
    watchFn: PropTypes.func,
    initialValue: PropTypes.any,
    onResolve: PropTypes.func,
    onReject: PropTypes.func,
    reducer: PropTypes.func,
    dispatcher: PropTypes.func,
    debugLabel: PropTypes.string
  },
  Initial: {
    children: childrenFn.isRequired,
    state: stateObject.isRequired,
    persist: PropTypes.bool
  },
  Pending: {
    children: childrenFn.isRequired,
    state: stateObject.isRequired,
    initial: PropTypes.bool
  },
  Fulfilled: {
    children: childrenFn.isRequired,
    state: stateObject.isRequired,
    persist: PropTypes.bool
  },
  Rejected: {
    children: childrenFn.isRequired,
    state: stateObject.isRequired,
    persist: PropTypes.bool
  },
  Settled: {
    children: childrenFn.isRequired,
    state: stateObject.isRequired,
    persist: PropTypes.bool
  }
};

var nullify = children => children === undefined ? null : children;

var renderFn = function renderFn(children) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return nullify(typeof children === "function" ? children(...args) : children);
};
/**
 * Renders only when no promise has started or completed yet.
 *
 * @prop {Function|Node} children Function (passing state) or React node
 * @prop {Object} state React Async state object
 * @prop {boolean} persist Show until we have data, even while pending (loading) or when an error occurred
 */


var Initial = (_ref) => {
  var {
    children,
    persist,
    state = {}
  } = _ref;
  return state.isInitial || persist && !state.data ? renderFn(children, state) : null;
};
/**
 * Renders only while pending (promise is loading).
 *
 * @prop {Function|Node} children Function (passing state) or React node
 * @prop {Object} state React Async state object
 * @prop {boolean} initial Show only on initial load (data is undefined)
 */

var Pending = (_ref2) => {
  var {
    children,
    initial,
    state = {}
  } = _ref2;
  return state.isPending && (!initial || !state.value) ? renderFn(children, state) : null;
};
/**
 * Renders only when promise is resolved.
 *
 * @prop {Function|Node} children Function (passing data and state) or React node
 * @prop {Object} state React Async state object
 * @prop {boolean} persist Show old data while pending (promise is loading)
 */

var Fulfilled = (_ref3) => {
  var {
    children,
    persist,
    state = {}
  } = _ref3;
  return state.isFulfilled || persist && state.data ? renderFn(children, state.data, state) : null;
};
/**
 * Renders only when promise is rejected.
 *
 * @prop {Function|Node} children Function (passing error and state) or React node
 * @prop {Object} state React Async state object
 * @prop {boolean} persist Show old error while pending (promise is loading)
 */

var Rejected = (_ref4) => {
  var {
    children,
    persist,
    state = {}
  } = _ref4;
  return state.isRejected || persist && state.error ? renderFn(children, state.error, state) : null;
};
/**
 * Renders only when promise is fulfilled or rejected.
 *
 * @prop {Function|Node} children Function (passing state) or React node
 * @prop {Object} state React Async state object
 * @prop {boolean} persist Show old data or error while pending (promise is loading)
 */

var Settled = (_ref5) => {
  var {
    children,
    persist,
    state = {}
  } = _ref5;
  return state.isSettled || persist && state.value ? renderFn(children, state) : null;
};

if (propTypes) {
  Initial.propTypes = propTypes.Initial;
  Pending.propTypes = propTypes.Pending;
  Fulfilled.propTypes = propTypes.Fulfilled;
  Rejected.propTypes = propTypes.Rejected;
  Settled.propTypes = propTypes.Settled;
}

var statusTypes = {
  initial: "initial",
  pending: "pending",
  fulfilled: "fulfilled",
  rejected: "rejected"
};
var getInitialStatus = (value, promise) => {
  if (value instanceof Error) return statusTypes.rejected;
  if (value !== undefined) return statusTypes.fulfilled;
  if (promise) return statusTypes.pending;
  return statusTypes.initial;
};
var getIdleStatus = value => {
  if (value instanceof Error) return statusTypes.rejected;
  if (value !== undefined) return statusTypes.fulfilled;
  return statusTypes.initial;
};
var getStatusProps = status => ({
  status,
  isInitial: status === statusTypes.initial,
  isPending: status === statusTypes.pending,
  isLoading: status === statusTypes.pending,
  // alias
  isFulfilled: status === statusTypes.fulfilled,
  isResolved: status === statusTypes.fulfilled,
  // alias
  isRejected: status === statusTypes.rejected,
  isSettled: status === statusTypes.fulfilled || status === statusTypes.rejected
});

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
var actionTypes = {
  start: "start",
  cancel: "cancel",
  fulfill: "fulfill",
  reject: "reject"
};
var init = (_ref) => {
  var {
    initialValue,
    promise,
    promiseFn
  } = _ref;
  return _objectSpread({
    initialValue,
    data: initialValue instanceof Error ? undefined : initialValue,
    error: initialValue instanceof Error ? initialValue : undefined,
    value: initialValue,
    startedAt: promise || promiseFn ? new Date() : undefined,
    finishedAt: initialValue ? new Date() : undefined
  }, getStatusProps(getInitialStatus(initialValue, promise || promiseFn)), {
    counter: 0
  });
};
var reducer = (state, _ref2) => {
  var {
    type,
    payload,
    meta
  } = _ref2;

  switch (type) {
    case actionTypes.start:
      return _objectSpread({}, state, {
        startedAt: new Date(),
        finishedAt: undefined
      }, getStatusProps(statusTypes.pending), {
        counter: meta.counter
      });

    case actionTypes.cancel:
      return _objectSpread({}, state, {
        startedAt: undefined,
        finishedAt: undefined
      }, getStatusProps(getIdleStatus(state.error || state.data)), {
        counter: meta.counter
      });

    case actionTypes.fulfill:
      return _objectSpread({}, state, {
        data: payload,
        value: payload,
        error: undefined,
        finishedAt: new Date()
      }, getStatusProps(statusTypes.fulfilled));

    case actionTypes.reject:
      return _objectSpread({}, state, {
        error: payload,
        value: payload,
        finishedAt: new Date()
      }, getStatusProps(statusTypes.rejected));

    default:
      return state;
  }
};
var dispatchMiddleware = dispatch => function (action) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  dispatch(action, ...args);

  if (action.type === actionTypes.start && typeof action.payload === "function") {
    action.payload();
  }
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(source, true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * createInstance allows you to create instances of Async that are bound to a specific promise.
 * A unique instance also uses its own React context for better nesting capability.
 */

var createInstance = function createInstance() {
  var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var displayName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Async";
  var {
    Consumer,
    Provider
  } = React.createContext();

  class Async extends React.Component {
    constructor(props) {
      super(props);
      this.start = this.start.bind(this);
      this.load = this.load.bind(this);
      this.run = this.run.bind(this);
      this.cancel = this.cancel.bind(this);
      this.onResolve = this.onResolve.bind(this);
      this.onReject = this.onReject.bind(this);
      this.setData = this.setData.bind(this);
      this.setError = this.setError.bind(this);
      var promise = props.promise;
      var promiseFn = props.promiseFn || defaultProps.promiseFn;
      var initialValue = props.initialValue || defaultProps.initialValue;
      this.mounted = false;
      this.counter = 0;
      this.args = [];
      this.abortController = {
        abort: () => {}
      };
      this.state = _objectSpread$1({}, init({
        initialValue,
        promise,
        promiseFn
      }), {
        cancel: this.cancel,
        run: this.run,
        reload: () => {
          this.load();
          this.run(...this.args);
        },
        setData: this.setData,
        setError: this.setError
      });
      this.debugLabel = props.debugLabel || defaultProps.debugLabel;
      var {
        devToolsDispatcher
      } = globalScope.__REACT_ASYNC__;

      var _reducer = props.reducer || defaultProps.reducer;

      var _dispatcher = props.dispatcher || defaultProps.dispatcher || devToolsDispatcher;

      var reducer$1 = _reducer ? (state, action) => _reducer(state, action, reducer) : reducer;
      var dispatch = dispatchMiddleware((action, callback) => {
        this.setState(state => reducer$1(state, action), callback);
      });
      this.dispatch = _dispatcher ? action => _dispatcher(action, dispatch, props) : dispatch;
    }

    componentDidMount() {
      this.mounted = true;

      if (this.props.promise || !this.state.initialValue) {
        this.load();
      }
    }

    componentDidUpdate(prevProps) {
      var {
        watch,
        watchFn = defaultProps.watchFn,
        promise,
        promiseFn
      } = this.props;

      if (watch !== prevProps.watch) {
        if (this.counter) this.cancel();
        return this.load();
      }

      if (watchFn && watchFn(_objectSpread$1({}, defaultProps, {}, this.props), _objectSpread$1({}, defaultProps, {}, prevProps))) {
        if (this.counter) this.cancel();
        return this.load();
      }

      if (promise !== prevProps.promise) {
        if (this.counter) this.cancel();
        if (promise) return this.load();
      }

      if (promiseFn !== prevProps.promiseFn) {
        if (this.counter) this.cancel();
        if (promiseFn) return this.load();
      }
    }

    componentWillUnmount() {
      this.cancel();
      this.mounted = false;
    }

    getMeta(meta) {
      return _objectSpread$1({
        counter: this.counter,
        debugLabel: this.debugLabel
      }, meta);
    }

    start(promiseFn) {
      if ("AbortController" in globalScope) {
        this.abortController.abort();
        this.abortController = new globalScope.AbortController();
      }

      this.counter++;
      return new Promise((resolve, reject) => {
        if (!this.mounted) return;

        var executor = () => promiseFn().then(resolve, reject);

        this.dispatch({
          type: actionTypes.start,
          payload: executor,
          meta: this.getMeta()
        });
      });
    }

    load() {
      var promise = this.props.promise;

      if (promise) {
        return this.start(() => promise).then(this.onResolve(this.counter), this.onReject(this.counter));
      }

      var promiseFn = this.props.promiseFn || defaultProps.promiseFn;

      if (promiseFn) {
        var props = _objectSpread$1({}, defaultProps, {}, this.props);

        return this.start(() => promiseFn(props, this.abortController)).then(this.onResolve(this.counter), this.onReject(this.counter));
      }
    }

    run() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var deferFn = this.props.deferFn || defaultProps.deferFn;

      if (deferFn) {
        this.args = args;

        var props = _objectSpread$1({}, defaultProps, {}, this.props);

        return this.start(() => deferFn(args, props, this.abortController)).then(this.onResolve(this.counter), this.onReject(this.counter));
      }
    }

    cancel() {
      var onCancel = this.props.onCancel || defaultProps.onCancel;
      onCancel && onCancel();
      this.counter++;
      this.abortController.abort();
      this.mounted && this.dispatch({
        type: actionTypes.cancel,
        meta: this.getMeta()
      });
    }

    onResolve(counter) {
      return data => {
        if (this.counter === counter) {
          var onResolve = this.props.onResolve || defaultProps.onResolve;
          this.setData(data, () => onResolve && onResolve(data));
        }

        return data;
      };
    }

    onReject(counter) {
      return error => {
        if (this.counter === counter) {
          var onReject = this.props.onReject || defaultProps.onReject;
          this.setError(error, () => onReject && onReject(error));
        }

        return error;
      };
    }

    setData(data, callback) {
      this.mounted && this.dispatch({
        type: actionTypes.fulfill,
        payload: data,
        meta: this.getMeta()
      }, callback);
      return data;
    }

    setError(error, callback) {
      this.mounted && this.dispatch({
        type: actionTypes.reject,
        payload: error,
        error: true,
        meta: this.getMeta()
      }, callback);
      return error;
    }

    render() {
      var {
        children
      } = this.props;

      if (typeof children === "function") {
        return React.createElement(Provider, {
          value: this.state
        }, children(this.state));
      }

      if (children !== undefined && children !== null) {
        return React.createElement(Provider, {
          value: this.state
        }, children);
      }

      return null;
    }

  }

  if (propTypes) Async.propTypes = propTypes.Async;

  var AsyncInitial = props => React.createElement(Consumer, null, st => React.createElement(Initial, _extends({}, props, {
    state: st
  })));

  var AsyncPending = props => React.createElement(Consumer, null, st => React.createElement(Pending, _extends({}, props, {
    state: st
  })));

  var AsyncFulfilled = props => React.createElement(Consumer, null, st => React.createElement(Fulfilled, _extends({}, props, {
    state: st
  })));

  var AsyncRejected = props => React.createElement(Consumer, null, st => React.createElement(Rejected, _extends({}, props, {
    state: st
  })));

  var AsyncSettled = props => React.createElement(Consumer, null, st => React.createElement(Settled, _extends({}, props, {
    state: st
  })));

  AsyncInitial.displayName = "".concat(displayName, ".Initial");
  AsyncPending.displayName = "".concat(displayName, ".Pending");
  AsyncFulfilled.displayName = "".concat(displayName, ".Fulfilled");
  AsyncRejected.displayName = "".concat(displayName, ".Rejected");
  AsyncSettled.displayName = "".concat(displayName, ".Settled");
  Async.displayName = displayName;
  Async.Initial = AsyncInitial;
  Async.Pending = AsyncPending;
  Async.Loading = AsyncPending; // alias

  Async.Fulfilled = AsyncFulfilled;
  Async.Resolved = AsyncFulfilled; // alias

  Async.Rejected = AsyncRejected;
  Async.Settled = AsyncSettled;
  return Async;
};
var Async = createInstance();

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(source, true).forEach(function (key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var noop = () => {};

var useAsync = (arg1, arg2) => {
  var options = typeof arg1 === "function" ? _objectSpread$2({}, arg2, {
    promiseFn: arg1
  }) : arg1;
  var counter = useRef(0);
  var isMounted = useRef(true);
  var lastArgs = useRef(undefined);
  var lastOptions = useRef(undefined);
  var abortController = useRef({
    abort: noop
  });
  var {
    devToolsDispatcher
  } = globalScope.__REACT_ASYNC__;
  var {
    reducer: reducer$1,
    dispatcher = devToolsDispatcher
  } = options;
  var [state, _dispatch] = useReducer(reducer$1 ? (state, action) => reducer$1(state, action, reducer) : reducer, options, init);
  var dispatch = dispatcher ? action => dispatcher(action, dispatchMiddleware(_dispatch), options) : dispatchMiddleware(_dispatch);

  var getMeta = meta => _objectSpread$2({
    counter: counter.current,
    debugLabel: options.debugLabel
  }, meta);

  var setData = function setData(data) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    if (isMounted.current) {
      dispatch({
        type: actionTypes.fulfill,
        payload: data,
        meta: getMeta()
      });
      callback();
    }

    return data;
  };

  var setError = function setError(error) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    if (isMounted.current) {
      dispatch({
        type: actionTypes.reject,
        payload: error,
        error: true,
        meta: getMeta()
      });
      callback();
    }

    return error;
  };

  var {
    onResolve,
    onReject
  } = options;

  var handleResolve = count => data => count === counter.current && setData(data, () => onResolve && onResolve(data));

  var handleReject = count => error => count === counter.current && setError(error, () => onReject && onReject(error));

  var start = promiseFn => {
    if ("AbortController" in globalScope) {
      abortController.current.abort();
      abortController.current = new globalScope.AbortController();
    }

    counter.current++;
    return new Promise((resolve, reject) => {
      if (!isMounted.current) return;

      var executor = () => promiseFn().then(resolve, reject);

      dispatch({
        type: actionTypes.start,
        payload: executor,
        meta: getMeta()
      });
    });
  };

  var {
    promise,
    promiseFn,
    initialValue
  } = options;

  var load = () => {
    if (promise) {
      return start(() => promise).then(handleResolve(counter.current), handleReject(counter.current));
    }

    var isPreInitialized = initialValue && counter.current === 0;

    if (promiseFn && !isPreInitialized) {
      return start(() => promiseFn(lastOptions.current, abortController.current)).then(handleResolve(counter.current), handleReject(counter.current));
    }
  };

  var {
    deferFn
  } = options;

  var run = function run() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (deferFn) {
      lastArgs.current = args;
      return start(() => deferFn(args, lastOptions.current, abortController.current)).then(handleResolve(counter.current), handleReject(counter.current));
    }
  };

  var cancel = () => {
    options.onCancel && options.onCancel();
    counter.current++;
    abortController.current.abort();
    isMounted.current && dispatch({
      type: actionTypes.cancel,
      meta: getMeta()
    });
  };

  var {
    watch,
    watchFn
  } = options;
  useEffect(() => {
    if (watchFn && lastOptions.current && watchFn(options, lastOptions.current)) load();
  });
  useEffect(() => (lastOptions.current = options) && undefined);
  useEffect(() => {
    if (counter.current) cancel();
    if (promise || promiseFn) load();
  }, [promise, promiseFn, watch]);
  useEffect(() => () => isMounted.current = false, []);
  useEffect(() => () => cancel(), []);
  useDebugValue(state, (_ref2) => {
    var {
      status
    } = _ref2;
    return "[".concat(counter.current, "] ").concat(status);
  });
  return useMemo(() => _objectSpread$2({}, state, {
    cancel,
    run,
    reload: () => lastArgs.current ? run(...lastArgs.current) : load(),
    setData,
    setError
  }), [state, deferFn, onResolve, onReject, dispatcher, reducer$1]);
};

var parseResponse = (accept, json) => res => {
  if (!res.ok) return Promise.reject(res);
  if (json === false) return res;
  if (json === true || accept === "application/json") return res.json();
  return res;
};

var useAsyncFetch = function useAsyncFetch(input, init) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var {
    defer,
    json
  } = _ref,
      options = _objectWithoutProperties(_ref, ["defer", "json"]);

  var method = input.method || init && init.method;
  var headers = input.headers || init && init.headers || {};
  var accept = headers["Accept"] || headers["accept"] || headers.get && headers.get("accept");

  var doFetch = (input, init) => globalScope.fetch(input, init).then(parseResponse(accept, json));

  var isDefer = defer === true || ~["POST", "PUT", "PATCH", "DELETE"].indexOf(method);
  var fn = defer === false || !isDefer ? "promiseFn" : "deferFn";
  var state = useAsync(_objectSpread$2({}, options, {
    [fn]: useCallback((_, props, ctrl) => doFetch(input, _objectSpread$2({
      signal: ctrl ? ctrl.signal : props.signal
    }, init)), [JSON.stringify(input), JSON.stringify(init)])
  }));
  useDebugValue(state, (_ref3) => {
    var {
      counter,
      status
    } = _ref3;
    return "[".concat(counter, "] ").concat(status);
  });
  return state;
};

var unsupported = () => {
  throw new Error("useAsync requires React v16.8 or up. Upgrade your React version or use the <Async> component instead.");
};

var useAsync$1 = useEffect ? useAsync : unsupported;
var useFetch = useEffect ? useAsyncFetch : unsupported;

export default Async;
export { Async, Fulfilled, Initial, Pending, Rejected, Settled, actionTypes, createInstance, dispatchMiddleware, globalScope, init, reducer, statusTypes, useAsync$1 as useAsync, useFetch };
